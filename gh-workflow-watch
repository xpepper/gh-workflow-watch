#!/usr/bin/env bash
set -euo pipefail

# gh extension: workflow-watch
# Usage: gh workflow-watch [-R owner/repo] [--branch branch-name] [--file workflow-file] [<workflow-name>]
# Watches the latest run of the given workflow until completion.
# If no workflow name is provided, shows interactive picker for running workflows.
# Exits with the run's conclusion status code when using --exit-status.

print_usage() {
  cat <<'EOF'
Usage: gh workflow-watch [-R owner/repo] [--branch branch-name] [--file workflow-file] [--exit-status] [--notify] [<workflow-name>]

Arguments:
  <workflow-name>           Name of the workflow (as shown by 'gh workflow list')
                            Or use --file to specify workflow by file path
                            If not provided, shows interactive picker for running workflows

Options:
  -R, --repo <owner/repo>   Repository to use (defaults to current repo if in a git directory)
  -b, --branch <branch>     Filter runs by branch
  -f, --file <file-path>    Specify workflow by file path (e.g., .github/workflows/ci.yml) instead of name
      --exit-status         Exit with non-zero status if run fails or is cancelled
      --notify             Send desktop notification when workflow completes
  -h, --help                Show this help message

Environment:
  GH_REPO                   If set, used as default for -R/--repo when not provided

Examples:
  gh workflow-watch build
  gh workflow-watch -R cli/cli test
  gh workflow-watch --branch develop build
  gh workflow-watch --file .github/workflows/ci.yml
  gh workflow-watch -R bellingcat/toolkit # Interactive selection
  GH_REPO=cli/cli gh workflow-watch "CI"
  gh workflow-watch --notify build # Get desktop notification when done
EOF
}

repo_flag=()
branch_flag=()
exit_status_flag=()
notify_flag=false
workflow_name=""
workflow_file=""

# Function to send desktop notifications
send_notification() {
  local title="$1"
  local message="$2"

  # macOS - using osascript (AppleScript)
  if [[ "$(uname)" == "Darwin" ]]; then
    osascript -e "display notification \"$message\" with title \"$title\""

  # Linux - using notify-send (requires libnotify)
  elif [[ "$(uname)" == "Linux" ]]; then
    if command -v notify-send >/dev/null 2>&1; then
      notify-send "$title" "$message"
    else
      echo "Warning: notify-send not found. Install libnotify-bin for notifications on Linux." >&2
    fi

  # Windows - using PowerShell (Windows 10+)
  elif [[ "$(uname -o)" == "Msys" ]] || [[ "$(uname -o)" == "Cygwin" ]]; then
    powershell -Command "Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.MessageBox]::Show('$message', '$title')"

  else
    echo "Warning: Desktop notifications not supported on this platform" >&2
  fi
}

# If GH_REPO is set, use it as default unless overridden later
if [[ -n "${GH_REPO:-}" ]]; then
  repo_flag=(-R "$GH_REPO")
fi

# Parse args
while [[ $# -gt 0 ]]; do
  case "$1" in
    -R|--repo)
      if [[ $# -lt 2 ]]; then
        echo "Error: missing value for $1" >&2
        exit 1
      fi
      repo_flag=(-R "$2")
      shift 2
      ;;
    -b|--branch)
      if [[ $# -lt 2 ]]; then
        echo "Error: missing value for $1" >&2
        exit 1
      fi
      branch_flag=(-b "$2")
      shift 2
      ;;
    -f|--file)
      if [[ $# -lt 2 ]]; then
        echo "Error: missing value for $1" >&2
        exit 1
      fi
      workflow_file="$2"
      shift 2
      ;;
    --exit-status)
      exit_status_flag=(--exit-status)
      shift
      ;;
    --notify)
      notify_flag=true
      shift
      ;;
    -h|--help)
      print_usage
      exit 0
      ;;
    --) # end of flags
      shift
      break
      ;;
    -*)
      echo "Unknown flag: $1" >&2
      echo >&2 "Use --help for usage"
      exit 1
      ;;
    *)
      # first positional = workflow name
      if [[ -z "$workflow_name" ]]; then
        workflow_name="$1"
        shift
      else
        echo "Unexpected extra argument: $1" >&2
        echo >&2 "Use --help for usage"
        exit 1
      fi
      ;;
  esac
done

if [[ -z "$workflow_name" && -z "$workflow_file" ]]; then
  # Interactive workflow selection mode
  echo "Fetching running workflows..." >&2
  # Get running workflows (status: in_progress, queued, requested)
  running_workflows=$(gh run list "${repo_flag[@]}" "${branch_flag[@]}" --json name,databaseId,status --jq '.[] | select(.status == "in_progress" or .status == "queued" or .status == "requested") | {name, databaseId, status}' 2>/dev/null)
  
  if [[ -z "$running_workflows" || "$running_workflows" == "null" ]]; then
    echo "No running workflows found" >&2
    exit 1
  fi
  
  echo "$running_workflows" > /tmp/gh_workflow_runs_$$
  
  # Count workflows
  count=$(echo "$running_workflows" | jq -s 'length')
  echo "Found $count running workflow(s):" >&2
  echo >&2
  
  # Display the workflows with numbers
  i=1
  while IFS= read -r line; do
    if [[ -n "$line" ]]; then
      workflow_name_temp=$(echo "$line" | jq -r '.name')
      run_id_temp=$(echo "$line" | jq -r '.databaseId')
      status_temp=$(echo "$line" | jq -r '.status')
      printf '%2d. %s (run %s, status: %s)\n' "$i" "$workflow_name_temp" "$run_id_temp" "$status_temp" >&2
      i=$((i+1))
    fi
  done < /tmp/gh_workflow_runs_$$
  echo >&2
  
  # Get user selection with visual indicator
  echo "Select a workflow to watch by entering its number:" >&2
  while true; do
    read -r -p "> " selection
    if [[ -n "$selection" && "$selection" =~ ^[0-9]+$ && "$selection" -ge 1 && "$selection" -lt "$i" ]]; then
      break
    else
      echo "Invalid selection. Please enter a number between 1 and $((i-1))." >&2
    fi
  done
  
  # Get the selected workflow
  selected_line=$(sed -n "${selection}p" /tmp/gh_workflow_runs_$$)
  workflow_name=$(echo "$selected_line" | jq -r '.name')
  run_id=$(echo "$selected_line" | jq -r '.databaseId')
  
  # Clean up
  rm /tmp/gh_workflow_runs_$$
  
  echo "Selected workflow '$workflow_name' (run $run_id)" >&2
else
  # If workflow file is specified, resolve it to workflow name
  if [[ -n "$workflow_file" ]]; then
    workflow_name=$(gh workflow list "${repo_flag[@]}" --json id,name,path --jq ".[] | select(.path == \"$workflow_file\") | .name" | head -n 1)
    if [[ -z "$workflow_name" || "$workflow_name" == "null" ]]; then
      echo "No workflow found for file '$workflow_file'" >&2
      echo "Tip: list workflows with: gh workflow list ${repo_flag[*]} --json id,name,path" >&2
      exit 1
    fi
  fi
  
  # Fetch latest run id for workflow
  run_id=$(gh run list "${repo_flag[@]}" "${branch_flag[@]}" -w "$workflow_name" -L 1 --json databaseId --jq '.[0].databaseId' || true)
  
  if [[ -z "$run_id" || "$run_id" == "null" ]]; then
    echo "No runs found for workflow '$workflow_name'" >&2
    echo "Tip: list workflows with: gh workflow list ${repo_flag[*]}" >&2
    exit 1
  fi
fi

echo "Watching workflow '$workflow_name' (run $run_id)..." >&2

# Watch the run until completion
# --exit-status returns non-zero on failure if requested
gh run watch "${repo_flag[@]}" "$run_id" "${exit_status_flag[@]}"

# If notifications are enabled, send one after completion
if [[ "$notify_flag" == "true" ]]; then
  # Get the conclusion of the completed run
  conclusion=$(gh run view "${repo_flag[@]}" "$run_id" --json conclusion --jq '.conclusion' 2>/dev/null || echo "unknown")

  # Map conclusion to user-friendly status
  case "$conclusion" in
    "success")
      status="✅ Success"
      ;;
    "failure")
      status="❌ Failed"
      ;;
    "cancelled")
      status="⚠️  Cancelled"
      ;;
    "skipped")
      status="⏭️  Skipped"
      ;;
    *)
      status="❓ $conclusion"
      ;;
  esac

  # Send notification
  send_notification "GitHub Workflow Completed" "$workflow_name: $status"
fi
